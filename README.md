# Process Miner Pro

A modular, high-performance Process Mining tool built in Python. It leverages **PM4Py** for mining algorithms and **Cython** for accelerated conformance checking. Designed to handle medium-to-large datasets on standard laptops (8GB RAM) through memory optimization and chunked loading.

## Features

* **Automated Discovery:** Supports Inductive, Heuristics, and Alpha Miners.
* **High-Performance Conformance:** Custom Cython implementation for fast fitness and alignment calculation.
* **Business Analytics:** Automated detection of bottlenecks, repeat purchase rates, and process deviations.
* **Memory Efficient:** Optimized data types and chunked CSV loading for constrained environments.
* **Visual Insights:** Auto-generates BPMN models for "Happy Paths" and "Main Process Flows".

---

## Installation & Setup

### 1. Prerequisites
* Python 3.9+
* [GraphViz](https://graphviz.org/download/) (Required for visualizations)
    * *Windows:* Download installer, run it, and **add GraphViz to System PATH**.
    * *Mac:* `brew install graphviz`

### 2. Install Python Dependencies
Run the following command in your terminal:
```bash
pip install -r requirements.txt

---

**Process mining documentation**

- The Process Model is your ideal customer journey map. The perfect, most efficient path you want users to take to convert (e.g., Homepage → Product Page → Add to Cart → Checkout → Purchase).
- The Event Log is the messy, real-world data of what all your users actually did.

Metrics
- Fitness: Can the model duplicate traces it finds in the log?
- Precision: Does the ideal map allow for crazy, nonsensical journeys that never happen?
- Alignment: A step by step score for how much a single user journey deviates from the ideal path (Deviations have a 'cost').

1. Fitness (Recall)
"Can the model replay the reality?"
What it measures: The percentage of traces in the Event Log that can be perfectly replayed by the Process Model from start to finish without forcing any token moves.

The Analogy:
Think of the Event Log as a set of Road Trips your visitors took, and the Process Model as a Map.
 - 100% Fitness: Every single road trip taken by a visitor exists on the map.
 - Low Fitness: Visitors are driving off-road, through fields and rivers, because the map doesn't show the roads they actually used.

2. Precision (Specificity)
"Is the model too vague?"

What it measures: Does the model allow for behavior that never actually happens?

The Analogy:
 - High Precision: The map shows only the roads people actually use.
 - Low Precision: The map shows a giant paved parking lot covering the whole world. Sure, you can drive anywhere (High Fitness!), but the map is useless because it doesn't tell you where the specific lanes are.

The "Flower Model" Trap: If you have a model where every activity connects to every other activity, you will have 100% Fitness (because anything is possible), but near 0% Precision (because it implies chaos).

**Petri net legenda**
*   Places (circles): state or condition that needs to be met before a transition can be carried out. Can hold a variable number of tokens (= resources)
*   Transitions (rectangles): represent events (actions) that can occur

**MODEL STATUS**
 - Compiled loops to C: **Active**. Compiled computationally expensive loops to C code for more speed.
 - Process map: **Active**. Generated by Discovery (Inductive Miner).
 - Bottlenecks: **Active**. Calculated from timestamps in the dataframe.
 - Trace deviations: **Active**. Calculated by Alignments (A*). See exactly which steps were skipped.
 - Variant analysis: **Active**. Statistical count of paths.
 - Fitness score: **Active**. Derived/Back-calculated from the Alignment Cost.
 - Preliminary fitness score (Token replay): **Inactive**. Too expensive for up to 16GB of RAM. Alignment cost fitness is more accurate.
 - Precision score: **Inactive**. Too expensive for up to 16GB of RAM. The only metric truly lost.
